\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=3cm, bottom=3cm, left=2.5cm, right=2.5cm]{geometry}
\geometry{a4paper} 

\usepackage{booktabs} 
\usepackage{array} 
\usepackage{multirow}
\usepackage{paralist} 
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{verbatim} 

\usepackage[output-decimal-marker={,}]{siunitx}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{url}
\graphicspath{{figures/}}

\newcommand\cplot{\texttt{plot}}
\newcommand\cstairs{\texttt{stairs}}
\newcommand\SIi{\SI[separate-uncertainty]}
\renewcommand\tt\texttt

\title{Design d'un network on chip}

\begin{document}
\maketitle

\section{Objectifs}

Les besoins croissants en bande passante de communication expliquent le recours aux technologies Network On Chip. Les réseaux sur puce offrent, en effet, des services plus étendus que les architectures à base de bus.

Dans le cadre général, la conception de la communication par réseaux commence par la définition d'un modèle de communication. Dans notre cas, il s'agit de 32 processeurs qui cherchent à communiquer de manière indifférenciée à 4 mémoires DDR2. Le sujet propose de diviser le réseau en deux sous-réseaux : une pour les communications des processeurs vers les mémoires (requêtes) et un autre pour les communication des mémoires vers les processeurs (réponses). Nous avons suivi cette proposition et nous sommes intéressés au premier sous réseau.

Selon le cahier des charge, le réseau doit aussi :
\begin{itemize}
\item garantir un débit de 100 Mbits/s pour chaque processeur,
\item garantir une latence maximale de 80 ns point à point,
\item permettre de configurer le réseau pour pouvoir utiliser différentes politiques d'arbitrage.
\end{itemize}

\section{Architecture - Modélisation SystemC}

Cette section décrit la modélisation du système en SystemC.

\subsection{Génération du traffic}
TODO: à compléter (structure des paquets, données, signal d'activation)

\subsection{Routeur}
Nous faisons correspondre à chaque entrée du système un module routeur, connecté à autant de FIFO qu'il y a de sorties au système.
Chacun de ces modules reçoit alors les données correspondant à son entrée en suivant un mécanisme de synchronisation de type handshake.

Sur un front montant de l'horloge, si le signal d'activation a une valeur positive,
le routeur lit un paquet et détermine la FIFO dans laquelle celui-ci doit être placé.
Le routeur lit ensuite le nombre d'emplacements libres de cette FIFO.
Si ce nombre est non nul, le paquet peut être écrit dans la FIFO.
Sinon, le routeur attend que la FIFO se désemplisse.
Une fois le paquet écrit dans la FIFO, le routeur émet un signal d'acquittement,
puis attend que le signal d'activation reprenne une valeur négative.
Une nouvelle valeur pourra alors être reçue suivant le même protocole.

\subsection{Arbitrage}
Similairement, nous faisons correspondre à chaque sortie du système un module d'arbitrage, connecté à autant de FIFO qu'il y a d'entrées au système.
Chacun de ces modules reçoit également en entrée un signal définissant un choix de stratégie d'arbitrage, déterminant dans quel ordre
les paquets en provenance des différentes entrées doivent être écrites en sortie.

Dans la mesure où le choix de stratégie d'arbitrage peut changer à tout moment,
l'abitrage se fait en 5 temps:
lecture du choix de stratégie d'arbitrage,
détermination de la FIFO sur laquelle lire le paquet (suivant la stratégie d'arbitrage choisie),
lecture du paquet dans la FIFO correspondante (s'il y a au moins une FIFO non vide),
écriture du paquet en sortie (ou d'une valeur par défaut si toutes les FIFO sont vides),
et mise à jour de l'état interne du module en vue d'arbitrages futurs.

La suite de cette partie détaille les différentes stratégies d'arbitrage modélisées et leur mise en oeuvre.

\subsubsection{Arbitrage suivant des priorités fixes}
Il s'agit de la stratégie d'arbitrage la plus simple: choisir la FIFO non vide la plus prioritaire.

Pour chaque FIFO, en suivant un ordre déterminé, le module lit donc le signal correspondant au nombre
de paquets disponibles.
La première FIFO non vide est alors choisie.

\subsubsection{Arbitrage en tourniquet}
Il s'agit d'une stratégie assez similaires à la précédente.
Le module choisit ici aussi la première FIFO non vide, en parcourant celles-ci dans un ordre déterminé,
mais cette fois il les parcourt à partir de la dernière FIFO lue.

Cette stratégie d'arbitrage nécessite de savoir à tout instant quelle est la dernière FIFO à avoir
été lue.
Il faut donc stocker cette information et la mettre à jour après chaque lecture.

\subsubsection{Arbitrage par choix de la moins récente utilisation}
Il s'agit cette fois de choisir la FIFO la moins récemment choisie.

La mise en oeuvre de cette stratégie repose sur l'utilisation d'un registre interne
dans lequel on stocke les indices des FIFOS par date de dernière utilisation, de la moins récente à la plus récente.
Le module  choisit alors la première FIFO non vide, en parcourant celles-ci dans l'ordre où leurs indices sont stockés
dans le registre.

Après une lecture, pour mettre à jour le registre, on décale vers le début de celui-ci toutes les valeurs
situées après celle correspondant à l'indice de la FIFO lue.
Cette dernière est ensuite écrite dans la dernière case du registre.

\subsubsection{Arbitrage de type FIFO}
Cette stratégie d'arbitrage est la plus complexe de celles présentées ici:
les paquets doivent être lus dans leur ordre d'arrivée, quelle que soit
la FIFO dans laquelle ils ont été placés.

Pour arriver à ce résultat, le module utilise un registre interne, initialement vide.
A chaque fois qu'une variable est écrite dans une des FIFOs, l'indice de cette FIFO est écrit dans ce registre
à une position correspondant au nombre de paquets présents dans l'ensemble des FIFOs.
Inversement, à chaque fois qu'un paquet est lu dans une FIFO, la première occurence de l'indice de cette
variable dans le registre est supprimée. Les valeurs du registres situées après cette occurence sont ensuite décalées vers le début du registre.

Ainsi, la première case du registre correspond toujours à l'indice de la FIFO contenant le paquet le plus ancien.

\subsubsection{Arbitrage aléatoire}
Pour choisir aléatoirement une FIFO dans laquelle lire, le module génère des nombres aléatoires
à l'aide d'un registre à décalage à rétroaction linéaire.
Ce nombre est ensuite ramené entre 0 et le nombre de FIFOs non vides, ce qui indique laquelle d'entre elles doit être choisie.

\section{Implémentation}

Cette section décrit un premier jet d'implémentation visant à déterminer un ordre de grandeur des performances atteignables et de la complexité du système.

\subsection{Protocole}
La communication entre les composants se fait par un protocole à deux phases. Deux fils (requête et acquittement) sont ajoutés au bus de données. Si ils sont au même niveau logique, le bus est considéré comme vide, sinon, il y a une donnée dessus. Ce protocole présente le désavantage de ne pas permettre de transmettre plus d'une donnée tous les deux cycles. En revanche, la conception de la FIFO est simplifiée.	

\subsection{FIFO}
Un étage de la FIFO est composé d'un banc de registre contenant au plus une donnée. On ajoute deux bascules contrôlant respectivement le fil de requête de cet étage et le fil d'acquittement du fil de l'étage précédent. Sur un front montant i l'étage précédent est plein et le présent est vide, le banc de registre copie la donnée et change l'état des bascules de contrôle. L'étage précédent est maintenant vide et l'étage actuel est plein.
Une FIFO est composée d'une succession, éventuellement vide, d'étages.

\subsection{Arbitre}
On utilise un codage one-hot pour désigner l'indice de la FIFO choisie. l'indice $-1$ est codé par "$0\dots0$"
\paragraph{Aléatoire}
L'implémentation reprend le code SystemC. L'indice de la FIFO choisie est extrait sous forme binaire et converti. L'indice choisi est renouvellé à chaque coup d'horloge.
\paragraph{Priorité fixe}
Un indice est choisi si et seulement si la FIFO correspondant n'est pas vide et aucun des indice plus prioritaire n'est choisi.
\paragraph{LRU}
les indices sont stockés du moins récemment utilisé au plus récemment utilisé. L'indice en tête est choisi. Pour la mise à jour, un indice progresse d'une case vers le moins récemment utilisé si l'indice réellement choisi a été moins récemment utilisé.
\paragraph{Priorité tournante}
L'arbitre stocke le dernier indice utilisé et accorde la priorité au suivant. Un indice est choisi si et sulement si il n'est pas vide et il est prioritaire ou alors le précédent est prioritaire et vide ou alors le précesseur du précédent est prioritaire ou vide\ldots
\paragraph{FIFO} Non implémenté.


\subsection{Routeur}

Pour chaque donnée reçue, le routeur décode l'adresse et inverse le bit de requête de la sortie correspondante. Les bits d'acquittements sont simplement aggrégé par des porte XOR et les données sont dirigées vers toutes les sorties.

\subsection{Performance et coût}

\subsubsection{Ressources logiques}
Le tableau \ref{perfs-sw-4} montre les ressources utilisées par un switch 4 vers 1 sur un FPGA Cyclone II. On remarque d'une part qu'en terme de ressources, les FIFOs sont rapidement les plus coûteuses (il y a quatre FIFO par switch et chaque étage a une largeur de $40+2$ bits). Ainsi, chaque étage de FIFO dans les switchs 8 vers 4 coûte $32*164=5248$ registres. Pour les switchs 4 vers 1, un étage n'utilise que 656 registres. Au total, le réseau complet avec des FIFOs de longueur 8 utilise de l'ordre de 50 000 registres.

Cela n'est pas bloquant pour une utilisation ou une émulation sur FPGA. Le nombre d'entrée/sorties (1600) est beaucoup plus gênant.

\begin{table}
\centering
\begin{tabular}{|c|c|c|}
\hline
Nombre d'étages de la fifo & Nombre de registres & Nombre de blocs logiques \\
\hline
0 & 93 & 181 \\
8 & 1405 & 258 \\
16 &  2717 & 312 \\
32 & 5341 & 452 \\
\hline \hline
éléments par étages & 164 & 8 \\
autres éléments & 93 & 184 \\
\hline
\end{tabular}
\caption{Ressources requises sur un Cyclone II par un switch 4 vers 1 selon la taille des FIFOs}
\label{perfs-sw-4}
\end{table}

\subsubsection{Débit et latence}
\`A cause du protocole, le débit maximal du circuit est limité à 1 élément par entrée/sortie par 2 cycles d'horloge.

La latence minimum d'une FIFO de $N$ étages varie de $N$ cycles si la FIFO est vide à $2N$ si elle est pleine. Le routeur ajoute un cycle de latence et la sortie aussi. Finalement, la latence d'un switch est comprise entre $N+2$ et $2N+2$.

\subsubsection{Fréquence d'horloge}
Compte tenu du cahier des charges, nous évaluons surtout la qualité de l'implémentation par sa fréquence d'horloge maximale. Le réseau entier étant trop gros (en terme d'entrées/sorties) pour les FPGAs Xilinx, nous n'avons pu que synthétiser, placer et router des morceaux du réseau. Nous supposons ensuite que, les interconnexions étant simples et les contraintes de placement pas trop fortes, la performance générale serait obtenue en gardant la moins bonne performance.

Nous nous sommes intéressés aux switchs. Pour les switchs 4 vers 1, la fréquence maximale est de 180 MHz pour un FPGA Virtex 5 (XC5VFX70T). Pour les switchs 8 vers 4, la fréquence maximale est de 100 MHz sur un Virtex 5 et 170 MHz sur un Virtex 7. Le chemin critique part de la sortie de FIFOs, passe par la logique de choix des arbitreurs, le multiplexeur de ces choix, le multiplexeur vers les données de sorties et arrive sur la bascule de sortie. Nous n'avons pas eu le temps de découper ce chemin. C'est en théorie possible car les arbitreurs n'ont à faire des choix que un cycle sur deux. Pour des ASICs, on peut s'attendre, selon la technologie de fabrication, à une multiplication de la fréquence par au moins 3. Néanmoins, nous n'avons pas pu synthétiser notre circuit vers un ASIC.

\section{Méthodologie}

D'abord, il opportun de rappeler que ce projet a pour vocation de nous sensibiliser à la conception des MPOC pour une application donnée et dans un contexte donné. Mème si on a été amenés à concevoir une architecture symètrique, l'un des objectifs de ce module est de se démarquer de cette vision esthétique des systèmes on chip qui pousse à envisager des matrices régulières de communication et donc des architectures régulières.  

\subsection{Contraintes}

La conception se réalise par rapport à un espace de contraintes <Q,R,T>. 

Q designe les contraintes de qualité de service. Le modèle de communication à satisfaire est une communication indifférenciée des processeurs avec les mémoires avec des contraintes de débit et de latence.

R désigne les ressources disponibles. Dans notre cas, nous sommes 4 et disposons d'un certain nombre de machines. Au niveau des ressources logicielles, nous disposons de nombreuses copies de SystemC et une machine pour ISE (liscence d'évaluation 30 jours) et une autre pour Quartus et la chaîne Alliance.

T désigne le temps le temps de travail disponible. Nous avons totalisé environs 46 heures de travail jusqu'ici. L'utilisation de la méthodologie proposée nécessiterait probablement encore 50 heures.

\subsection{Méthodologie}

La méthodologie proposée se décompose en 3 étapes détaillées ci-dessous :
\begin{enumerate}
\item Le choix de l'espace de conception
\end{enumerate}

Dans la méthodologie de conception qu'on propose il y a 3 étapes : 
\paragraph{Choix de l'espace de conception}
Le but de cet étape est de définir les constantes et les variables qui seront utilisées dans l'exploration. Pour les constantes de conception, nous avons fixé un protocole, l'architecture des switchs et du routeur et une modèle. Les variables sont alors la taille des FIFOs et l'agencement des switchs.

\paragraph{Affectation des variables}

\paragraph{Extraction des caractéristiques de l'implémentation}
Une fois les paramètres d'architecture fixés, il définir un simulateur et une implémentation. L'implémentation doit fournir au simulateur les caractéristiques du réseau en fonction du des variables de conception. Cela peut passer par un générateur de code VHDL écrit par exemple en Perl et ensuite des scripts qui compilent ce code et extraient les contraintes d'horloge, les latences et les débits des switchs.

\paragraph{Simulation haut niveau et validation}
Le simulateur récupère ces informations et simule le système complet soumis au(x) modèle(s) de traffic pour obtenir des indicateurs globaux de performance. Si ceux-ci sont satisfaisant, on s'arrête. Sinon, on passe à l'étape suivante.

	

    2)Extraction des paramètres des éléments matéreils

    3)Simulation haut niveau et validation
	-Les paramètres récupérés des éléments matériels permettrons d'annoter les modèles haut niveau (SystemC)
	- La specification de l'application permet de définir un modèle de communication pour la simulation.
	-La simulation (atteinte rapidement) permettra de valider le comportement de chaque modèle. 
	

    Ouverture : adaptation au traffic réel
	<Q,R,T>
	Paramètres de choix : espace de conception
	Extraction des paramètres des éléments matéreils
	Simulation haut niveau et validation
	Ouverture : adaptation au traffic réel

\section{Réflexion}
	Conception
	Pareto
	Outils de CAO
	Simulation multiphysique
	Mur de la simulation et extraction de modèle
		équilibre on veut tout prendre en compte, on ne peut pas tout simuler en même temps
		des paramètres globaux dépendent grandement de l'implémentation (ex: conso)
	Repousser le front de Pareto ?
		Ouvrir des nouveaux paramètres (ex 3D : ajouter une dimension)
		Elargir les panels existant (ex : routeur optique)
		=> comment ? "Recherche" puis intégration
	Itération et convergence
		itération : architecture -> simule -> analyse -> nouvelle archi *améliorée*
		amélioration : analyse "intelligente" : idée de loi de variation, pb chaos non déterministe



\end{document}
